<link rel="import" href="../polymer/polymer.html">

<!--
`payment-request`
Payment request API implementation

@demo demo/index.html
-->

<dom-module id="payment-request">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>
    <content id="methods" select="payment-method"></content>
    <content id="items" select="payment-item.item"></content>
    <content id="total" select="payment-item#total"></content>
    <content id="buyButton" select="#buyButton"></content>
  </template>

  <script>
    Polymer({

      is: 'payment-request',

      /**
       * Fired when begin user interaction for the payment request.
       *
       * @event response
       * @param {PaymentResponse} paymentResponse The payment information to process.
       */

       /**
       * Fired when the payment request is aborted
       *
       * @event aborted
       */

       /**
       * Fired when payment request generate an error.
       *
       * @event error
       * @param {Error} error The request error.
       */

       /**
       * Fired when PaymentRequest object can be used to make a payment.
       *
       * @event can-make-payment
       */

       /**
       * Fired when PaymentRequest object cannot be used to make a payment.
       *
       * @event cannot-make-payment
       */


      properties: {

        /**
         * This is a human-readable description of the total.
         * The user agent may display this to the user.
         */
        label: String,

        /**
         * A valid decimal monetary value containing a monetary amount of the total
         */
        value: Number,

        /**
         * A string containing a currency identifier of the total.
         * The value of currency can be any string that is valid within
         * the currency system indicated by currencySystem.
         */
        currency: {
          type: String,
          value: 'EUR'
        },

        /**
         * Contains line items for the payment request that the user agent may display.
         */
        items: {
          type: Array,
          readOnly: true,
          notify: true,
          observer: '_updateTotal',
          value: function() {
            return [];
          },
        },

        /**
         * Contains the total amount of the payment request.
         */
        total: {
          type: Object,
          readOnly: true,
          notify: true,
          value: function() {
            return {};
          }
        },

        /**
         * Is used to store supported payment methods and
         * any associated payment method specific data for those methods.
         */
        methods: {
          type: Array,
          readOnly: true,
          value: function() {
            return [];
          }
        },

        /**
         * Provides information about the requested transaction.
         */
        details: {
          type: Object,
          computed: '_computeDetails(total, items)',
        },

        lastCanMakePayment: {
          type: Boolean,
          readOnly: true
        },

        lastRequest: {
          type: Object,
          notify: true,
          computed: '_computeRequest(methods, details)'
        },

        lastResponse: {
          type: Object,
          readOnly: true,
          notify: true
        },

        lastError: {
          type: Object,
          readOnly: true,
          notify: true,
          observer: '_dispatError'
        }
      },

      attached: function() {
        this._updatePropertiesFromNodes();
        var buyButton = Polymer.dom(this.$.buyButton).getDistributedNodes()[0];
        this.listen(buyButton, 'tap', 'buyButtonTap');
      },

      detached: function() {
        this.__unobserveNodes('items');
      },

      _updatePropertiesFromNodes: function() {
        this.__updatePropertyFromNode('methods');
        this.__updatePropertyFromNode('items');
      },

      __updatePropertyFromNode: function(property, observerInfo) {
				observerInfo = observerInfo || {
					target: this.$[property],
					addedNodes: Polymer.dom(this.$[property]).getDistributedNodes(),
					removedNodes: []
				};
				// Add items from added nodes
				observerInfo.addedNodes.forEach(function(node){
					this.splice(property, this[property].length, 0, node.dictionary);
				}.bind(this));
				// Remove items from removed nodes
				observerInfo.removedNodes.forEach(function(node){
					this.splice(property, this[property].indexOf(node.dictionary), 1);
				}.bind(this));
        this.__observeNodes(property);
      },

      __observerNode: function(node) {
        return '_' + node + 'Observer';
      },

      __observeNodes: function(property) {
        // Watch for future updates.
        if (!this[this.__observerNode(property)]) {
          this[this.__observerNode(property)] = Polymer.dom(this.$[property]).observeNodes(this.__updatePropertyFromNode.bind(this, property));
        }
      },

      __unobserveNodes: function(property) {
        if (this[this.__observerNode(property)]) {
          Polymer.dom(this).unobserveNodes(this[this.__observerNode(property)]);
        }
      },

      _mapItemsToPropery: function(node) {
          return {
            label: node.label,
            amount: node.amount
          };
      },

      _mapMethodsToPropery: function(node) {
          return {
            supportedMethods: node.supported,
            data: node.data
          };
      },

      _updateTotal: function() {
        var totalDom = Polymer.dom(this.$.total);
        var total = totalDom.getDistributedNodes()[0];
        if (!total) {
          total = this.create('payment-item');
          totalDom.appendChild(total);
        }
        var currency = this.items.length ?
          this.items[0].amount.currency :
          this.currency;
        var value = 0;
        for (var i = 0; i < this.items.length; i++) {
          value += this.items[i].amount.value;
        }
        total.set('label', this.label || 'Total');
        total.set('value', value);
        total.set('currency', currency);

        this._setTotal({
          label: total.label,
          amount: total.amount
        });
      },

      _computeDetails: function(total, items) {
        return {
          total: total,
          displayItems: items
        };
      },

      /**
       * Construct a PaymentRequest using the supplied methodData list including any
       * payment method specific data, the payment details, and the payment options
       *
       * @return  {PaymentRequest}
       */
      _computeRequest: function(methods, details) {
        return methods && methods.length && window.PaymentRequest ? new PaymentRequest(methods, details) : null;
      },

      /**
       * Method executed when payButton is tapped.
       * You can override it to do something more complex.
       */
      buyButtonTap: function() {
        if ('PaymentRequest' in window) {
          this.show();
        } else {
          this._setLastError({
            detail: 'Payment Request API not supported'
          });
        }
      },

      /**
       * Determine if the PaymentRequest object can be used to make a payment.
       *
       * @return {Promise}
       */
      canMakePayment: function() {
        var promise;
        if (this.lastRequest && this.lastRequest.canMakePayment) {
          promise = this.lastRequest.canMakePayment()
            .then(function(canMakePayment) {
              this._setLastError(null);
              this._setLastCanMakePayment(canMakePayment);
              if (canMakePayment) {
                event = 'can';
              } else {
                event = 'cannot';
              }
              this.dispatchEvent(new CustomEvent(event + '-make-payment', {
                detail: canMakePayment
              }));
            }.bind(this))
            .catch(function(error) {
              this._setLastError(error);
              this.dispatchEvent(
                new CustomEvent('error', {
                  detail: error
                })
              );
            }.bind(this));
        } else {
          promise = new Promise(function(resolve, reject) {
            resolve();
          });
        }
        return promise;
      },

      /**
       * Begin user interaction for the payment request.
       *
       * @return {Promise}
       */
      show: function() {
        var promise;
        if (this.lastRequest.show) {
          promise = this.lastRequest.show()
            .catch(this._updateItems.bind(this))
            .then(this._setLastResponse.bind(this))
        }
        return promise.catch(this._setLastError.bind(this));
      },

      /**
       * Abort the payment request
       * @return {Promise}
       */
      abort: function() {
        var promise;
        if (this.lastRequest) {
          promise = this.lastRequest.abort()
            .then(function() {
              this._setLastResponse(null);
              this.dispatchEvent(
                new CustomEvent('aborted')
              );
            }.bind(this));
        } else {
          promise = new Promise(function(resolve, reject) {
            resolve('There aren\'t any active request');
          });
        }
        return promise.catch(this._setLastError.bind(this));
      },

      _dispatError: function(error) {
        this.dispatchEvent(
          new CustomEvent('error', {
            detail: error
          })
        );
        return error;
      },

      _dispatResponse: function(response) {
        if (response !== null) {
          this.dispatchEvent(
            new CustomEvent('response', {
              detail: response
            })
          );
        }
        return response;
      }

    });
  </script>
</dom-module>
